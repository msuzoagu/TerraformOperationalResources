---
AWSTemplateFormatVersion: '2010-09-09'
Description: |
  create associated terraform backend resources for TerraformAdminRole
Metadata:
  AWS::Cloudformation::Interface:
    ParameterGroups: 
      - Label: 
          default: trusting account
        Parameters: 
          - Region          
          - TrustingAccount
      - Label: 
          default: trusted account
        Parameters: 
          - TrustedAccount          
      - Label: 
          default: terraform backend resources for **enviroment-projectname**
        Parameters:
          - TagKey
          - TagVal
          - Region
          - RoleName
          - LockTable
          - LogBucket
          - StateBucket
          - TrustedAccount
          - TrustingAccount
Parameters:
  TagKey:
    Type: String
    Description: |
      Principal Tag Key      
  TagVal:  
    Type: String
    Description: |
      Principal Tag Key          
  Region:
    Type: String
    Description: |
      Region where resorces are created    
  RoleName: 
    Type: String
    Description: |
      Name of role used to access terraform backend resources     
  LockTable: 
    Type: String
    Description: |
      Name of the terraform DynamoDB lock table  
  LogBucket: 
    Type: String
    Description: |
      Name of the S3 bucket for terraform state logs                        
  StateBucket: 
    Type: String
    Description: |
      Name of the S3 bucket for terraform state  
  TrustingAccount:
    Type: String
    Description: |
      Resources are created here              
  TrustedAccount:
    Type: String
    Description: |
      Has access to resouces in trusting account        
Rules:
  EnsureDeployingToCorrectAccount:
    Assertions:
      - Assert: !Equals
          - !Ref AWS::AccountId
          - !Ref TrustingAccount
        AssertDescription: 'Stack must be deployed in the specified aws account'
Resources: 
  ##############################
  # Create Terraform Resources #
  ##############################
  LogBucket:
    Type: 'AWS::S3::Bucket'
    DeletionPolicy: Delete
    UpdateReplacePolicy: Retain
    Properties:
      BucketName: !Ref LogBucket
      AccessControl: LogDeliveryWrite
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: aws:kms
      PublicAccessBlockConfiguration:
        BlockPublicAcls: True
        BlockPublicPolicy: True
        IgnorePublicAcls: True
        RestrictPublicBuckets: True                  
  
  LockTable:
    Type: 'AWS::DynamoDB::Table'
    DeletionPolicy: Delete
    UpdateReplacePolicy: Retain
    Properties:
      TableName: !Ref LockTable
      AttributeDefinitions:
        - AttributeName: LockID
          AttributeType: S
      KeySchema:
        - AttributeName: LockID
          KeyType: HASH
      BillingMode: PAY_PER_REQUEST                

  StateBucket:
    Type: 'AWS::S3::Bucket'
    DeletionPolicy: Delete
    UpdateReplacePolicy: Retain
    Properties:
      BucketName: !Ref StateBucket
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: aws:kms
      LoggingConfiguration:
        DestinationBucketName: !Ref LogBucket
        LogFilePrefix: TerraformStateLogs/
      PublicAccessBlockConfiguration:
        BlockPublicAcls: True
        BlockPublicPolicy: True
        IgnorePublicAcls: True
        RestrictPublicBuckets: True
      VersioningConfiguration:
        Status: Enabled  

  StateBucketPolicy:
    Type: 'AWS::S3::BucketPolicy'
    DeletionPolicy: Delete
    UpdateReplacePolicy: Retain
    Properties: 
      Bucket: !Ref StateBucket
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          #############################################
          # Require TLS always                        #
          #############################################
          - Sid: 'AllowTLSRequestsOnly'
            Effect: Deny
            Action: '*'
            Principal: '*'
            Condition:
              Bool:
                'aws:SecureTransport': false
            Resource:
              - !GetAtt "StateBucket.Arn"
              - !Sub
                - "${Bucket}/*"
                - Bucket: !GetAtt "StateBucket.Arn"  
          
          

          ####################
          ####################
          # User Permissions #
          ####################
          ####################
          
          #####################################################
          #    deny access to users lacking TagKey TagVal     #
          #####################################################
          - Sid: DenyAccess2NonTerrformbackendUsers
            Effect: Deny
            Action: '*'
            Principal: 
              AWS:
                - !Sub "arn:aws:iam::${TrustedAccount}:root"            
            Condition:
              StringEquals:
                aws:PrincipalType: User
              StringNotLike:
                "aws:PrincipalTag/${TagKey}": "*"
            Resource:
              - !GetAtt "StateBucket.Arn"
              - !Sub
                - "${Bucket}/*"
                - Bucket: !GetAtt "StateBucket.Arn"

          ###############################################
          #    grant read/write acccess to user with    #
          #    matching TagKey and TagVal               #
          ###############################################
          - Sid: GrantAccess2TerrformbackendUsers
            Effect: Allow
            Action: 
              - 's3:GetObject'
              - 's3:ListBucket'
              - 's3:PutObject'
              # Granting DeleteObject is safe because 
              # we have versioning enabled on the bucket. 
              # DeleteObjectVersion is what we have to 
              # restrict so that someone can't delete the 
              # delete marker and thereby permanently delete 
              # state. Granting DeleteObject is helpful 
              # because it allows NonAdmins to migrate 
              # state (i.e., rename state files)
              - 's3:DeleteObject'                          
              - 's3:GetBucketVersioning'
            Principal:
              AWS:
                - !Sub "arn:aws:iam::${TrustedAccount}:root"
            Condition:
              StringEquals:
                aws:PrincipalType: User
              StringLike:
                "aws:PrincipalTag/${TagKey}": "${TagVal}"   
            Resource:
              - !GetAtt "StateBucket.Arn"
              - !Sub
                - "${Bucket}/*"
                - Bucket: !GetAtt "StateBucket.Arn"


          ####################
          ####################
          # Role Permissions #
          ####################
          ####################

          #############################################
          #    If principal is an assumed role but    #
          #    role is not ${RoleName}, deny access   #
          #############################################
          - Sid: DenyAccess2NonTerraformBackendRole
            Effect: Deny
            Action: '*'
            Principal:
              AWS:
                - !Sub "arn:aws:iam::${TrustedAccount}:root"
            Condition:
              StringEquals:
                aws:PrincipalType: AssumedRole
              StringNotLike:
                aws:userId:
                  - !Sub
                    - "${RoleId}:*"
                    - RoleId: !GetAtt "Role.RoleId"   
            Resource:
              - !GetAtt "StateBucket.Arn"
              - !Sub
                - "${Bucket}/*"
                - Bucket: !GetAtt "StateBucket.Arn"  

          ##################################################
          #    if principal is an assumed IAM role and     #
          #    role is RoleName, grant read/write access   #
          ##################################################
          - Sid: AssumeRoleReadWrite
            Effect: Allow
            Action:
              - 's3:GetObject'
              - 's3:PutObject'            
              - 's3:ListBucket'
              - 's3:GetBucketVersioning'
            Principal:
              AWS:
                - !Sub "arn:aws:iam::${TrustedAccount}:root"
            Condition:
              StringEquals:
                aws:PrincipalType: AssumedRole         
              StringLike:
                aws:userId:
                  - !Sub
                    - "${RoleId}:*"
                    - RoleId: !GetAtt "Role.RoleId"
            Resource:
              - !GetAtt "StateBucket.Arn"
              - !Sub
                - "${Bucket}/*"
                - Bucket: !GetAtt "StateBucket.Arn"                